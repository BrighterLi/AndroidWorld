内存使用优化
【Android 性能优化】—— 详解内存优化的来龙去脉: https://blog.csdn.net/qq_23191031/article/details/63685756
什么是内存
通常情况下我们说的内存是指手机的RAM，它主要包括一下几个部分：
1）寄存器（Registers读音：[ˈrɛdʒɪstɚ]）
速度最快的存储场所，因为寄存器位于处理器内部，所以在程序中我们无法控制。
2）栈（Stack）
存放基本类型的对象和引用，但是对象本身不存放在栈中，而是存放在堆中。
变量其实是分为两部分的：一部分叫变量名，另外一部分叫变量值，对于局部变量（基本类型的变量和对象的引用变量）而言，统一都存放在栈中，但是变量值中存储的内容就有在一定差异了：Java中存在8大基本类型，他们的变量值中存放的就是具体的数值，而其他的类型都叫做引用类型（对象也是引用类型，你只要记住除了基本类型，都是引用类型）他们的变量值中存放的是他们在堆中的引用（内存地址）。
在函数执行的时候，函数内部的局部变量就会在栈上创建，函数执行结束的时候这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集中是一块连续的内存区域，效率很高，速度快，但是大小是操作系统预定好的所以分配的内存容量有限。
3）堆（Heap）
在堆上分配内存的过程称作 内存动态分配过程。在java中堆用于存放由new创建的对象和数组。堆中分配的内存，由java虚拟机自动垃圾回收器（GC）来管理(可见我们要进行的内存优化主要就是对堆内存进行优化)。堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit系统理论上是4G）
4）静态存储区/方法区（Static Field）
是指在固定的位置上存放应用程序运行时一直存在的数据，java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量。
5）常量池（Constant Pool）
顾名思义专门存放常量的。注意 String s = "java"中的“java”也是常量。JVM虚拟机为每个已经被转载的类型维护一个常量池。常量池就是该类型所有用到地常量的一个有序集合包括直接常量（基本类型，String）和对其他类型、字段和方法的符号引用。
###总结：
1)定义一个局部变量的时候，java虚拟机就会在栈中为其分配内存空间，局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。因为它们属于方法中的变量，生命周期随方法而结束。
2)成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体），因为它们属于类，类对象终究是要被new出来使用的。当堆中对象的作用域结束的时候，这部分内存也不会立刻被回收，而是等待系统GC进行回收。
3)所谓的内存分析，就是分析Heap中的内存状态。

Generational Heap Memory内存模型的概述
在Android和Java中都存在着一个Generational（读音：[ˌdʒenəˈreɪʃənl]） Heap Memory模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。Generational Heap Memory模型主要由：Young Generation（新生代）、Old Generation（旧生代）、Permanent(读音：[ˈpɜ:rmənənt]) Generation三个区域组成，而且这三个区域存在明显的层级关系。所以此模型也可以成为三级Generation的内存模型。

Dalvik 和标准Java虚拟机的主要区别?
Dalvik虚拟机（DVM）是Android系统在java虚拟机（JVM）基础上优化得到的，DVM是基于寄存器的，而JVM是基于栈的，由于寄存器高效快速的特性，DVM的性能相比JVM更好。
Dalvik 和 java 字节码的区别?
Dalvik执行.dex格式的字节码文件，JVM执行的是.class格式的字节码文件，Android程序在编译之后产生的.class 文件会被aapt工具处理生成R.class等文件，然后dx工具会把.class文件处理成.dex文件，最终资源文件和.dex文件等打包成.apk文件。

分别对Young Generation（新生代）和Old Generation（旧生代）采用的两种垃圾回收机制？

如何判断对象是否可以被回收?
现在的垃圾回收机制已经不太使用引用计数器的方法判断是否可回收，而是使用跟踪收集器方法。
现在大多数JVM采用对象引用遍历机制从程序的主要运行对象(如静态对象/寄存器/栈上指向的堆内存对象等)开始检查引用链，去递归判断对象收否可达，如果不可达，则作为垃圾回收，当然在便利阶段，GC必须记住那些对象是可达的，以便删除不可到达的对象，这称为标记（marking）对象。
下一步，GC就要删除这些不可达的对象，在删除时未必标记的对象，释放它们的内存的过程叫做清除（sweeping），而这样会造成内存碎片化，布局已分配给新的对象，但是他们集合起来还很大。所以很多GC机制还要重新组织内存中的对象，并进行压缩，形成大块、可利用的空间。
为了达到这个目的，GC需要停止程序的其他活动，阻塞进程。这里我们要注意的是：**不要频繁的引发GC，执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行, 故而如果程序频繁GC, 自然会导致界面卡顿. **通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms。可参见《【Android 性能优化】—— UI篇》)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。

什么内存泄漏?
为什么不能被回收?
如何的监听系统发生GC?
 DVM中
 D/dalvikvm(30615): GC FOR ALLOC freed 4442K, 25% free 20183K/26856K, paused 24ms , total 24ms
ART中
I/art(198): Explicit concurrent mark sweep GC freed 700(30KB) AllocSpace objects, 0(0B) LOS objects, 792% free, 18MB/21MB, paused 186us total 12.763ms
导致GC频繁执行有两个原因?
1) Memory Churn（内存抖动），内存抖动是因为大量的对象被创建又在短时间内马上被释放。
2) 瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加 Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。

检测工具
严格模式StrictMode
LeakCanary:
LeakCanary会检测应用的内存回收情况，如果发现有垃圾对象没有被回收，就会去分析当前的内存快照，也就是上边MAT用到的.hprof文件，找到对象的引用链，并显示在页面上。这款插件的好处就是,可以在手机端直接查看内存泄露的地方,可以辅助我们检测内存泄露

内存泄漏
非静态内部类
https://www.cnblogs.com/Jack-cx/p/10190739.html
Android 非静态内部类导致的内存泄露（非static内部类）：https://blog.csdn.net/lsyz0021/article/details/51473819

内存使用性能优化具体操作
【Android 性能优化】—— 详解内存优化的来龙去脉: https://blog.csdn.net/qq_23191031/article/details/63685756
ANDROID内存优化(大汇总——上): https://blog.csdn.net/a396901990/article/details/37914465
1、引入自动检测模式：StrictMode LenkCanry
2、针对具体的相关页面进行检测内存使用情况分析：内存大小，内存峰值，内存抖动，内存泄漏
内存使用情况：
Process Stats:了解你的APP如何使用内存: https://blog.csdn.net/a396901990/article/details/38390135
android+查看内存容量apk,如何检查 Android 应用的内存使用情况: https://blog.csdn.net/weixin_39940344/article/details/117643354
Android获取App内存使用情况: https://blog.csdn.net/u010029439/article/details/109385206
procstats,meminfo
Android 4.4 KitKat 提出了一个新系统服务，叫做procstats。它将帮助你更好的理解你app在后台（background）时的内存使用情况。
           Procstats可以去监视你app在一段时间的行为，包括在后台运行了多久，并在此段时间使用了多少内存。从而帮助你快速的找到应用中不效率和不规范的地方去避免影响其performs，尤其是在低内存的设备上运行时。

内存泄漏检测：
手把手教你在Android Studio 3.0上分析内存泄漏： https://www.jianshu.com/p/bdfd2a6b2681
profile；MAT
首先需要明白一个概念, 内存泄露就是指,本应该回收的内存,还驻留在内存中。 一般情况下,高密度的手机,一个页面大概就会消耗20M内存,如果发现退出界面,程序内存迟迟不降低的话,可能就发生了严重的内存泄露。 我们可以反复进入该界面，然后点击dump Java heap 这个按钮,然后Android Studio就开始干活了,下面的图就是正在dump
